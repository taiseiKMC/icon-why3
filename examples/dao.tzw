scope Preambles
  meta "algebraic:kept" type (nat, address)
  meta "algebraic:kept" type option (nat, address)


  type poll [@gen_wf] = {
    proposal : lambda unit unit; (* lambda unit (list operation) *)
    author : address;
    votingStartBlock : nat;
    votingEndBlock : nat;
    yayVotes : nat;
    nayVotes : nat;
    abstainVotes : nat;
    totalVotes : nat;
    voters : map address bool
  }
  meta "algebraic:kept" type option poll
  meta "algebraic:kept" type (option (nat, address), option poll)
end

scope Postambles
  predicate addr_inv (c : ctx) =
    c.dAO_storage.DAO.tokenAddress = Token.addr

  predicate storage_inv (c : ctx) =
    c.dAO_storage.DAO.voteState = None
end

scope Unknown

  predicate pre (c : ctx) =
    addr_inv c /\
    storage_inv c

  predicate post (_c : ctx) (c' : ctx) =
    addr_inv c' /\
    storage_inv c'

  scope Entrypoint

  predicate default unit

  end

end

scope DAO

  type storage [@gen_wf] = {
    poll : option poll;
    tokenAddress : address; (* FA2 *)
    escrowAmount : nat; (* poll のための deposit *)
    voteLength : nat;
    percentageForSuperMajority : nat;
    voteState : option (nat, address);
  }

  predicate pre (st : step) (gp : gparam) (c : ctx) =
    match st.entrypoint, gp with
    | ICon.Contract.VoteCallback, ICon.Gp (p : (nat, address)) ->
        st.sender <> Token.addr -> storage_inv c
    | _ -> storage_inv c
    end /\ addr_inv c

  predicate post (_st : step) (_gp : gparam) (c : ctx) (c' : ctx) = inv_post c c'

  let upper_ops = 2

  scope Spec
    (*
    entrypoint propose (proposal)
    {
      assert(poll == None)
      (* endVote を呼ばせるためのインセンティブ && proposal を出せる資格? *)
      transfer(tokenAddress%transfer, 0, {from = sender, txs = [{to_ = self_address, amount = escrowAmount, token_id=0}]})
      poll = Some
        { proposal, author = sender
          votingStartBlock=level, votingEndBlock = level+voteLength,
          yayVotes=0, nayVotes=0, abstainVotes=0, totalVotes=0,
          voters=empty_set}
    }
    *)
    (* predicate propose
      (st : step)
      (proposalLambda : lambda unit operation)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      ops = Nil /\
      match s.poll with
      | None ->
          let level = level st in
          let poll = Some
            { proposal = proposalLambda;
              author = sender st;
              votingStartBlock = level;
              votingEndBlock = level + s.voteLength;
              yayVotes = 0;
              nayVotes = 0;
              abstainVotes = 0;
              totalVotes = 0;
              voters = fun _ -> False
            }
          in
          s' = { s with poll = poll }
      | Some _ -> False
      end *)

    (*
    entrypoint endVote ()
    {
      assert(is_some(poll))
      let Some p = poll in
      assert(p.votingEndBlock < level)
      totalOpinionatedVotes = p.yayVotes + p.nayVotes
      (* yayVotesNeededForEscrowReturn = totalOpinionatedVotes * minYayVotesPercentForEscrowReturn / 100 (* 一定の支持を得られなければボッシュート *) *)
      yayVotesNeededForSuperMajority = totalOpinionatedVotes * percentageForSuperMajority / 100
      transfer(tokenAddress%transfer, 0, {from = self_address, txs=[{to_=p.sender, amount=escrowAmount, token_id=0}]})
      if(yayVotesNeededForSuperMajority <= yayVotes (* && quorum <= p.totalVotes *))
      {
        p.proposal ()
      }
    }
    *)
    (* predicate endVoting
      (st : step)
      (_p : unit)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      match s.poll with
      | None -> False
      | Some poll ->
          poll.votingEndBlock < level st /\
          let totalOpinionatedVotes = poll.yayVotes + poll.nayVotes in
          let yayVotesNeededForSuperMajority = totalOpinionatedVotes * s.percentageForSuperMajority in
          let op = Xfer (ICon.Gp ((self st, poll.author, s.escrowAmount) : (address, address, nat))) 0 (ICon.Contract.transfer s.tokenAddress) in
          { s with poll = None } = s' /\
          ops = if yayVotesNeededForSuperMajority <= poll.yayVotes * 100
                  then Cons op (Cons (poll.proposal ()) Nil) (* p.proposal *)
                  else Cons op Nil
      end *)

    (*
    entrypoint vote (voteValue) (* voteValue... 0 for yay, 1 for nay, 2 for abstain *)
    {
      assert(voteState == None)
      voteState = Some { voteValue, address=sender }
      transfer((* escrowAddress%getBalance *) tokenAddress%getBalance, 0, { address, callback=voteCallback })
    }
     *)
    predicate vote
      (st : step)
      (voteValue : nat)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      match s.voteState with
      | Some _ -> true
      | None ->
          let addr = sender st in
          { s with voteState = Some (voteValue, addr) } = s' /\
          let callback = ICon.Contract.voteCallback (self st) in
          ops = Cons (Xfer (ICon.Gp ((addr, callback) : (address, contract))) 0 (ICon.Contract.getBalance s.tokenAddress)) Nil
      end

    (*
    entrypoint voteCallback(balance)
    {
      assert (is_some (voteState))
      assert (is_some (p))
      let Some vote = voteState in
      let Some p = poll in
      assert (level < p.votingEndBlock)
      if (p.voters.mem(vote.address)) assert false (* 投票済み *)
      p.voters.add(vote.address)
      p.totalVotes += balance
      if (vote.voteValue == 0) p.yayVotes += balance
      else if (vote.voteValue == 1) p.nayVotes += balance
      else if (vote.voteValue == 2) p.abstainVotes += balance
      else assert false
      poll = Some p
      voteState = None
    }
     *)

    predicate voteCallback
      (st : step)
      (p : (nat, address))
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      let (value, addr) = p in
      match (s.voteState, s.poll) with
      | Some (voteValue, addr), Some poll ->
          level st < poll.votingEndBlock /\
          poll.voters[addr] /\
          let totalVotes = poll.totalVotes + value in
          let yayVotes = if voteValue = 0 then poll.yayVotes + value else poll.yayVotes in
          let nayVotes = if voteValue = 1 then poll.nayVotes + value else poll.nayVotes in
          let abstainVotes = if voteValue = 2 then poll.abstainVotes + value else poll.abstainVotes in
          let voters = poll.voters[addr <- True] in
          let poll =
            Some
              { poll with yayVotes = yayVotes
              ; nayVotes = nayVotes
              ; abstainVotes = abstainVotes
              ; totalVotes = totalVotes
              ; voters = voters }
          in
          { s with voteState = None; poll = poll } = s' /\
          ops = Nil
      | _ -> false
      end
  end

end

scope Token
  type storage [@gen_wf] = {
    balances : map (address) nat;
    admin : address;
    approvals : map address (map address nat);
  }

  predicate pre (st : step) (_gp : gparam) (c : ctx) =
    addr_inv c /\
    match _gp with
    | ICon.Gp (p : (address, contract)) ->
        (st.sender <> DAO.addr -> storage_inv c) /\
        (st.sender = DAO.addr ->
          let addr, callback = p in
          callback = ICon.Contract.voteCallback st.sender)
    | _ -> false
    end

  predicate post (_st : step) (_gp : gparam) (c : ctx) (c' : ctx) = inv_post c c'

  let upper_ops = 1

  scope Spec
    (* predicate transfer
      (st : step)
      (p : (address, address, nat))
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      let from_, to_, value = p in
      let sender = sender st in
      (from_ = sender \/ sender = s.admin \/ s.approvals[from_][sender] >= value) /\
      
      s.balances[from_] >= value /\
      let to_balance = s.balances[to_] + value in
      let b = s.balances[to_ <- to_balance] in
      let from_balance = s'.balances[from_] + value in
      let b' = s'.balances[from_ <- from_balance] in
      b = b' /\

      if sender <> s.admin /\ sender <> from_
      then s'.approvals[from_][sender] + value = s.approvals[from_][sender]
      else True /\
      s.admin = s'.admin /\
      s.approvals = s'.approvals /\
      ops = Nil *)

    predicate getBalance
      (st : step)
      (p : (address, contract))
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      let addr, callback = p in
      let value = s.balances[addr] in
      ops = Cons (Xfer (ICon.Gp ((value, addr) : (nat, address))) 0 callback) Nil /\
      s = s'
  
    (* predicate mint
      (st : step)
      (p : (address, nat))
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      let addr, value = p in
      sender st = s.admin /\
      ops = Nil /\
      let v = s.balances[addr] + value in
      s' = { s with balances = s.balances[addr <- v] } *)

  end
end
