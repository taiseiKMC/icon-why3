(* why3 prove -P z3 だと通らないが ide だと通る *)
scope Preambles
  use string.String
  use list.Length
  use list.Map
  use list.Quant
  use list.FoldLeft

  function sum_of : (map address nat) -> nat

  axiom SumE : sum_of (const 0) = 0

  axiom SumI : forall m k v.
    v >= 0 ->
    m[k] >= 0 /\ (* これ上手いこと自動でできない？ *)
    sum_of m[k <- v] = sum_of m + v - m[k]

  meta "algebraic:kept" type (map nat (map address nat), map nat (map address nat))
  meta "algebraic:kept" type (bool, (map nat (map address nat), map nat (map address nat)))
  meta "algebraic:kept" type (address, (nat, nat))

  function update_balance
    (from_ : address)
    (to_ : address)
    (token_id : nat)
    (amount : nat)
    (balances : map nat (map address nat))
    (balances' : map nat (map address nat))
    : (map nat (map address nat), map nat (map address nat)) =
    let b = balances[token_id] in
    let to_balance = b[to_] + amount in
    let b = b[to_ <- to_balance] in
    let b' = balances'[token_id] in
    let from_balance = b'[from_] + amount in
    let b' = b'[from_ <- from_balance] in
    (balances[token_id <- b], balances'[token_id <- b'])
end

scope Postambles

  predicate balances_invariant (c : ctx) (c' : ctx) = true
    (* forall a. sum_of c.token_storage.Token.balances[a] = sum_of c'.token_storage.Token.balances[a]
    (* 正しいが自動では示せない *) *)
end

scope Unknown
  predicate pre (c : ctx) = true

  predicate post (c : ctx) (c' : ctx) =
    balances_invariant c c'

  scope Entrypoint
    predicate default unit
  end

end

scope Swap

  type storage [@gen_wf] = { }

  predicate pre (st : step) (gp : gparam) (c : ctx) = true

  predicate post (_st : step) (gp : gparam) (c : ctx) (c' : ctx) =
    balances_invariant c c' /\
    match gp with
    | Gp'Swap'swap a_addr a_token_id a_amount b_addr b_token_id b_amount ->
        c.token_storage.Token.operators[a_token_id][a_addr][Swap.addr] /\
        c.token_storage.Token.operators[b_token_id][b_addr][Swap.addr] /\
        ( let balances = c.token_storage.Token.balances in
          let balances' = c'.token_storage.Token.balances in
          let balances, balances' = update_balance a_addr b_addr a_token_id a_amount balances balances' in
          let balances, balances' = update_balance b_addr a_addr b_token_id b_amount balances balances' in
          balances = balances'
        )
    | _ -> false
    end

  let upper_ops = 2

  scope Spec
    predicate swap
      (st : step)
      (a_addr : address)
      (a_token_id : nat)
      (a_amount : nat)
      (b_addr : address)
      (b_token_id : nat)
      (b_amount : nat)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      (* a_token_id <> b_token_id /\ (* for simplicity *) *)
      a_addr <> self st /\
      b_addr <> self st /\
      let op0 = Xfer (Gp'Token'transfer a_addr (Cons (b_addr, (a_token_id, a_amount)) Nil)) 0 Token.addr in
      let op1 = Xfer (Gp'Token'transfer b_addr (Cons (a_addr, (b_token_id, b_amount)) Nil)) 0 Token.addr in
      ops = Cons op0 (Cons op1 Nil)

  end

end

scope Token
  type storage [@gen_wf] = {
    balances : map nat (map address nat);
    operators : map nat (map address (map address bool));
  }

  predicate pre (st : step) (gp : gparam) (c : ctx) = true

  predicate post (st : step) (gp : gparam) (c : ctx) (c' : ctx) =
    balances_invariant c c' /\
    match gp with
    | Gp'Token'transfer from_ l ->
        let sender = sender st in
        let (f, (b, b')) =
          fold_left
            (fun acc e ->
              let f, (b, b') = acc in
              let to_, (token_id, amount) = e in
              let b, b' = update_balance from_ to_ token_id amount b b' in
              let f = f /\ (from_ = sender \/ c.token_storage.Token.operators[token_id][from_][sender]) in
              (f, (b, b'))
              )
            (true, (c.token_storage.Token.balances, c'.token_storage.Token.balances))
            l in
        f /\ b = b' /\
        c.token_storage.Token.operators = c'.token_storage.Token.operators
    | Gp'Token'update_operators _ ->
        c.token_storage.Token.balances = c'.token_storage.Token.balances
    | _ -> false
    end

  let upper_ops = 0

  predicate update_operator
    (st : step)
    (op : or (address, (address, nat)) (address, (address, nat)))
    (s : storage)
    (s' : storage) =
      let sender = sender st in
      match op with
      | Left (owner, (ope, token_id)) ->
          owner = sender /\
          s'.operators[token_id][owner][ope]
      | Right (owner, (ope, token_id)) ->
          owner = sender /\
          not s'.operators[token_id][owner][ope]
      end

  scope Spec

    predicate transfer
      (st : step)
      (from_ : address)
      (l : list (address, (nat, nat))) (* from_, [(to, token_id, amount)] *)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
        let sender = sender st in
        let (f, (b, b')) =
          fold_left
            (fun acc e ->
              let f, (b, b') = acc in
              let to_, (token_id, amount) = e in
              let b, b' = update_balance from_ to_ token_id amount b b' in
              let f = f /\ (from_ = sender \/ s.operators[token_id][from_][sender]) /\ b'[token_id][from_] >= 0 in
              (f, (b, b'))
              )
            (true, (s.balances, s'.balances))
            l in
        f /\ b = b' /\
        s.operators = s'.operators /\
        ops = Nil

    (* predicate balance_of
      (st : step)
      (req : list (address, nat)) (* (owner, token_id) *)
      (callback : contract (list ((address, nat), nat))) (* ((owner, token_id), balance) *)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      let value = s.balances[addr] in
      let l =
        map
          (fun r ->
            let (owner, token_id) = r in
            r, s.balances[token_id][owner]) req in
      ops = Cons (Xfer (callback l) 0 (sender st)) Nil /\
      s = s' *)
  
  predicate update_operators
    (st : step)
    (e : (or (address, (address, nat)) (address, (address, nat))))
    (* add_operator (owner, operator, token_id), remove_operator (owner, operator, token_id) *)
    (s : storage)
    (ops : list operation)
    (s' : storage) =
      update_operator st e s s' /\
      s.balances = s'.balances /\
      ops = Nil

  end
end
