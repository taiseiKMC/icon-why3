scope Preambles
  use export int.Int
  use export int.Abs
  use export int.EuclideanDivision
  use export list.List
  use export option.Option
  use export map.Map
  use export map.Const

  exception Insufficient_mutez
  exception Terminate

  type nat = int

  type mutez = int

  type bytes = string

  type big_map 'a 'b = map 'a 'b

  type address = int

  type key_hash = int

  type timestamp = int

  type contract 'a = int

  type or 'a 'b = Left 'a | Right 'b

  type lambda 'a 'b = 'a -> 'b

  type step = (address, address, address, mutez, nat)

  function mk_step (source : address) (sender : address) (self : address) (amount : mutez) (level : nat) : step =
    (source, sender, self, amount, level)

  function source (st : step) : address =
    match st with x, _, _, _ ,_ -> x end

  function sender (st : step) : address =
    match st with _, x, _, _ ,_ -> x end

  function self (st : step) : address =
    match st with _, _, x, _ ,_ -> x end

  function amount (st : step) : mutez =
    match st with _, _, _, x ,_ -> x end

  function level (st : step) : nat =
    match st with _, _, _, _, x -> x end

  predicate st_wf (st : step) =
    st.amount >= 0

end

scope Unknown

  predicate pre (c : ctx) =
    c.dAO_storage.DAO.voteState = None

  predicate post (_c : ctx) (c' : ctx) =
    c'.dAO_storage.DAO.voteState = None

  scope Entrypoint

  predicate default unit

  end

end

scope DAO

  (* 
  type poll = {
    proposal : lambda unit (list operation),
    author : address,
    votingStartBlock : nat
    votingEndBlock : nat,
    yayVotes : nat,
    nayVotes : nat,
    abstainVotes : nat,
    totalVotes : nat,
    voters : set address
  } *)
  type storage = {
    poll : option (lambda unit (list operation), address, nat, nat, nat, nat, nat, nat, map address bool);
    tokenAddress : address; (* FA2 *)
    escrowAmount : nat; (* poll のための deposit *)
    voteLength : nat;
    percentageForSuperMajority : nat;
    voteState : option (nat, address);
  }

  predicate pre (_c : ctx) = true

  predicate post (_st : step) (_gp : gparam) (c : ctx) (c' : ctx) = inv_post c c'

  let upper_ops = 3

  scope Spec
    (*
    entrypoint propose (proposal)
    {
      assert(poll == None)
      (* endVote を呼ばせるためのインセンティブ && proposal を出せる資格? *)
      transfer(tokenAddress%transfer, 0, {from = sender, txs = [{to_ = self_address, amount = escrowAmount, token_id=0}]})
      poll = Some
        { proposal, author = sender
          votingStartBlock=level, votingEndBlock = level+voteLength,
          yayVotes=0, nayVotes=0, abstainVotes=0, totalVotes=0,
          voters=empty_set}
    }
    *)
    predicate propose
      (st : step)
      (proposalLambda : lambda unit (list operation))
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      ops = Nil /\
      match s.poll with
      | None ->
          let level = level st in
          let poll = Some (proposalLambda, sender st, level, level + s.voteLength, 0, 0, 0, 0, fun _ -> False) in
          s = { s' with poll=poll }
      | Some _ -> False
      end

    (* 
    entrypoint endVote ()
    {
      assert(is_some(poll))
      let Some p = poll in
      assert(p.votingEndBlock < level)
      totalOpinionatedVotes = p.yayVotes + p.nayVotes
      (* yayVotesNeededForEscrowReturn = totalOpinionatedVotes * minYayVotesPercentForEscrowReturn / 100 (* 一定の支持を得られなければボッシュート *) *)
      yayVotesNeededForSuperMajority = totalOpinionatedVotes * percentageForSuperMajority / 100
      transfer(tokenAddress%transfer, 0, {from = self_address, txs=[{to_=p.sender, amount=escrowAmount, token_id=0}]})
      if(yayVotesNeededForSuperMajority <= yayVotes (* && quorum <= p.totalVotes *))
      {
        p.proposal ()
      }
    }
    *)
    predicate endVoting
      (st : step)
      (_p : unit)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      match s.poll with
      | None -> False
      | Some (proposal, author, votingStartBlock, votingEndBlock, yayVotes, nayVotes, abstainVotes, totalVotes, voters) ->
          votingEndBlock < level _st /\
          let totalOpinionatedVotes = yayVotes + nayVotes in
          let yayVotesNeededForSuperMajority = totalOpinionatedVotes * s.percentageForSuperMajority in
          let op = Xfer (Gp'Token'transfer (self st) author s.escrowAmount) 0 s.tokenAddress in
          ops = if yayVotesNeededForSuperMajority <= yayVotes * 100
                  then Cons op (proposal ()) (* p.proposal *)
                  else Cons op Nil
      end

    (*
    entrypoint vote (voteValue) (* voteValue... 0 for yay, 1 for nay, 2 for abstain *)
    {
      assert(voteState == None)
      voteState = Some { voteValue, address=sender }
      transfer((* escrowAddress%getBalance *) tokenAddress%getBalance, 0, { address, callback=voteCallback })
    }
     *)
    predicate vote
      (st : step)
      (voteValue : nat)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      match s.voteState with
      | Some _ -> False
      | None ->
        let addr = sender st in
        s'.voteState = Some (voteValue, addr) /\
        ops = Cons (Xfer (Gp'Token'getBalance addr 0(* Gp'DAO'voteCallback *)) 0 s.tokenAddress) Nil
      end

    (*
    entrypoint voteCallback(balance)
    {
      assert (is_some (voteState))
      assert (is_some (p))
      let Some vote = voteState in
      let Some p = poll in
      assert (level < p.votingEndBlock)
      if (p.voters.mem(vote.address)) assert false (* 投票済み *)
      p.voters.add(vote.address)
      p.totalVotes += balance
      if (vote.voteValue == 0) p.yayVotes += balance
      else if (vote.voteValue == 1) p.nayVotes += balance
      else if (vote.voteValue == 2) p.abstainVotes += balance
      else assert false
      poll = Some p
      voteState = None
    }
     *)
    predicate voteCallback
      (st : step)
      (value : nat)
      (addr : address)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      match (s.voteState, s.poll) with
      | Some (voteValue, addr), Some p ->
          let (_proposal, _author, _votingStartBlock, votingEndBlock, yayVotes, nayVotes, abstainVotes, totalVotes, voters) = p in
          level st < votingEndBlock /\
          voters[addr] /\
          let totalVotes = totalVotes + value in
          let yayVotes = if voteValue = 0 then yayVotes + value else yayVotes in
          let nayVotes = if voteValue = 1 then nayVotes + value else nayVotes in
          let abstainVotes = if voteValue = 2 then abstainVotes + value else abstainVotes in
          let voters = voters[addr <- True] in
          s'.poll = Some (_proposal, _author, _votingStartBlock, votingEndBlock, yayVotes, nayVotes, abstainVotes, totalVotes, voters) /\
          s'.voteState = None /\
          ops = Nil
      | _ -> ops = Nil
      end
  end

end

scope Token
  type storage = {
    balances : map (address) nat;
    admin : address;
    approvals : map address (map address nat);
  }

  predicate pre (_c : ctx) = true

  predicate post (_st : step) (_gp : gparam) (c : ctx) (c' : ctx) = inv_post c c'

  let upper_ops = 2

  scope Spec
    predicate transfer
      (st : step)
      (from_ : address)
      (to_ : address)
      (value : nat)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
      let sender = sender st in
      (from_ = sender \/ sender = s.admin \/ s.approvals[from_][sender] >= value) /\
      s.balances[from_] >= value /\
      s'.balances[from_] = s.balances[from_] - value /\
      s'.balances[to_] = s.balances[to_] + value /\
      if sender <> s.admin /\ sender <> from_
      then s'.approvals[from_][sender] + value = s.approvals[from_][sender]
      else True /\
      s.admin = s'.admin /\
      ops = Nil

    predicate getBalance
      (st : step)
      (addr : address)
      (callback : contract (nat, address))
      (s : storage)
      (ops : list operation)
      (s' : storage) =
    let value = s.balances[addr] in
    ops = Cons (Xfer (callback value addr) 0 (sender st)) Nil /\
    s = s'
  
    predicate mint
      (st : step)
      (addr : address)
      (value : nat)
      (s : storage)
      (ops : list operation)
      (s' : storage) =
    sender st = s.admin /\
    ops = Nil /\
    s' = { s with balances = s.balances[addr] + value} 
      
  end
end
